import json
import time

# START - CODE GENERATED BY GPT
def solution():
    max_cycle = 0
    result = 0
    for d in range(2, 1000):
        remainders = [0] * d
        num = 1
        position = 0
        while remainders[num] == 0 and num != 0:
            remainders[num] = position
            num *= 10
            num %= d
            position += 1
        if position - remainders[num] > max_cycle:
            max_cycle = position - remainders[num]
            result = d
    return result

# Explanation:

# We need to find the value of *d* \< 1000 for which <sup>1</sup>/<sub>*d*</sub> contains the longest recurring cycle in its decimal fraction part. To do this, we can use a brute force approach and check for each value of *d* from 2 to 999, what is the length of the recurring cycle in the decimal representation of <sup>1</sup>/<sub>*d*</sub>.

# To find the length of the recurring cycle, we can use the concept of remainders. When we divide 1 by *d*, we get a remainder. We can then multiply this remainder by 10 and divide by *d* again to get the next remainder. We keep doing this until we get a remainder that we have already seen before. The length of the recurring cycle is the difference between the current position and the position where we first saw the remainder.

# We can keep track of the remainders we have seen before using a list. We initialize a list of length *d* with all elements as 0. We then start with num = 1 and keep multiplying it by 10 and taking the remainder with *d* until we get a remainder that we have seen before or we get a remainder of 0 (which means that the decimal representation terminates). We keep track of the position of each remainder in the list. If we see a remainder that we have seen before, we calculate the length of the recurring cycle and update the maximum length and the result.

# Finally, we return the result which is the value of *d* for which the length of the recurring cycle is maximum.
# END - CODE GENERATED BY GPT

cpu_s, wall_s = time.process_time(), time.time()
result = solution()
cpu_e, wall_e = time.process_time(), time.time()

cpu_time, wall_time = cpu_e - cpu_s, wall_e - wall_s
print(json.dumps({"solution": result, "cpu": cpu_time, "wall": wall_time}))
